## 代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问

**在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。**

### 简介
#### 意图：
    为其他对象提供一种代理以控制对这个对象的访问。
#### 主要解决：
    在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），
    直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。
#### 何时使用：
    想在访问一个类时做一些控制。
#### 如何解决：
    增加中间层。
#### 优点： 
    1、职责清晰。 
    2、高扩展性。 
    3、智能化。
#### 缺点： 
    1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 
    2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。
#### 使用场景： 
    按职责来划分，通常有以下使用场景： (多种变种)
    1、远程代理。 
    2、虚拟代理。 
    3、Copy-on-Write 代理。 
    4、保护（Protect or Access）代理。 
    5、Cache代理。 
    6、防火墙（Firewall）代理。 
    7、同步化（Synchronization）代理。 
    8、智能引用（Smart Reference）代理。
### 示例中的关系图
    不提供了  变种太多
### 参考地址
http://www.runoob.com/design-pattern/proxy-pattern.html
### 关于JDK和CGLIB的动态代理简要描述
    Java Dynamic Proxy：
        特点: 只能对接口进行代理  
        采用的方式: 通过反射机制进行调用
        使用方式: 
            1.创建一个实现了InvocationHandler接口的拦截类
            2.通过Proxy#newProxyInstance(ClassLoader, Class<?>[], InvocationHandler)静态方法创建目标的代理
    CGLIB：    
        特点: 不受必须实现接口的限制,但对于final方法无法代理
        采用的方式: 生成要代理目标的子类,重写目标中的非final方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。
        使用方式:
            1.创建一个实现了MethodInterceptor接口的拦截类
            2.通过对Enhancer对象实例设置属性(setSuperclass(Class) 和 setCallback(Callback) 等)来创建目标的代理
